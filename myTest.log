{
    "query": {
    "bool": {
      "must": [
        {
          "term": {
            "LotNumber": {
              "value": "HG50212"
            }
          }
        },
        {
          "term": {
            "Operation": {
              "value": "FT"
            }
          }
        },
        {
          "term": {
            "Type": {
              "value": "PinMeasure"
            }
          }
        },
        {
          "term": {
            "Pin": {
              "value": "S_VDDCR_SOC"
            }
          }
        }
      ],
      "filter": {
        "terms": {
          "context": [
            "Sidd_VddCrSoc_V1",
            "Sidd_VddCrSoc_V3"
          ]
        }
      }
    }
  },
  "aggs": {
    "UnitId": {
      "terms": {
        "field": "UnitId",
        "size": 3000
      },
      "aggs": {
        "TestName": {
          "terms": {
            "field": "context"
          },
          "aggs": {
            "Avg": {
              "avg": {
                "field": "value"
              }
            }
          }
        }
      }
    }
  }
}


// js

({
  after_render: function() {
    
    var svgViewport = d3.select("#viz")
        .append("svg")
        .attr("width",800)
        .attr("height",600);

    var margin = {top: 80, right: 50, bottom: 50, left: 75},
        width  = 800 - margin.left - margin.right,           
        height = 600 - margin.top  - margin.bottom;

    var innerSpace = svgViewport.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
    // define the data
    var a  = response.aggregations.UnitId.buckets;
   
   var minX = d3.min(a, function(d, i) { return a[i].TestName.buckets[0].Avg.value; });
   var maxX = d3.max(a, function(d, i) { return a[i].TestName.buckets[0].Avg.value; });
   
   var minY = d3.min(a, function(d, i) { return a[i].TestName.buckets[1].Avg.value; });
   var maxY = d3.max(a, function(d, i) { return a[i].TestName.buckets[1].Avg.value; });
   
   console.log("minX = " + minX);
   console.log("maxX = " + maxX);
   
   console.log("minY = " + minY);
   console.log("maxY = " + maxY);
   
   // 1) change the scale
    var xAxisScale = d3.scale.linear()
        .domain([minX, maxX])
        .range( [0, width])
        .nice();
    
    var yAxisScale = d3.scale.linear()
    .domain([minY, maxY])
    .range( [height, 0])
    .nice();
        
    // 2) redefine the axis
   
    var myXAxis = d3.svg.axis().scale(xAxisScale).orient("bottom");
    var myYAxis = d3.svg.axis().scale(yAxisScale).orient("left");
    
    // 3) redraw the axis
    var axisXGroup = innerSpace.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(myXAxis);
    
    var axisYGroup = innerSpace.append("g")
    .attr("class", "y axis")
    .call(myYAxis);
    
    
    innerSpace.selectAll("scatter")
    .data(a)
    .enter()
    .append("circle") 
        .style("stroke", "gray") 
        .style("fill", "white")
        
        .attr("r", function(d, i){
            return 10 ;
        })
        .attr("cx", function(d, i){
            return xAxisScale(a[i].TestName.buckets[0].Avg.value);
        })
        .attr("cy",  function(d, i){
            return yAxisScale( a[i].TestName.buckets[1].Avg.value);
        })
        .on("mouseover", function(d,i){
            d3.select(this).style("fill", "aliceblue");
            var str ="UnitID = " +  a[i].key + ", "
            + a[i].TestName.buckets[0].key + " = " + a[i].TestName.buckets[0].Avg.value + ", "
            + a[i].TestName.buckets[1].key + " = " + a[i].TestName.buckets[1].Avg.value;
            //d3.select(".chart-header").text(JSON.stringify(this, null, ' '));
            d3.select(".chart-header").text(str);
            
        })
        .on("mouseout", function(){d3.select(this).style("fill", "white");
             d3.select(".chart-header").text("");
        });
        
    innerSpace.append("text")
      .attr("transform", "translate(0,-10)")
      .text("title")
      .classed("chart-header", true)
      .attr("x", 0)
      .attr("y", -50);
      
      
      
      
      
      
/**      
    var jsonCircles = [ { "x_axis": 30, "y_axis": 30, "radius": 20, "color" : "green" },
    { "x_axis": 70, "y_axis": 70, "radius": 20, "color" : "purple"},
    { "x_axis": 110, "y_axis": 100, "radius": 20, "color" : "red"}];
    

 var circles = svgContainer.selectAll("circle")
    .data(jsonCircles)
    .enter()
    .append("circle");



var circleAttributes = circles
    .attr("cx", function (d) { return d.x_axis; })
    .attr("cy", function (d) { return d.y_axis; })
    .attr("r", function (d) { return d.radius; })
    .style("fill", function(d) { return d.color; });
**/
    
  },
  count_hits: function() {
  return this.response.hits.hits.length;
 },
 count_aggs: function() {
     var a  = response.aggregations.UnitId.buckets;
     return a[0].TestName.buckets[0].Avg.value;
 },
  all_aggs: function() {
     var a = this.response.aggregations.UnitId.buckets;
     return a;
 },
 debug: function() {
  return JSON.stringify(this, null, ' ');
 } 
})

// template
<div id="viz"> </div>

<hr>{{meta.count_aggs}} agg cont <hr>
<hr>

<table width=100% border=1>
{{#response.aggregations.UnitId.buckets}} 
<tr>
 <td> {{key}} </td>
 {{#TestName.buckets}}
 <td> {{key}} </td>
 <td> {{Avg.value}} </td>
 
 {{/TestName.buckets}} 
 
</tr>
{{/response.aggregations.UnitId.buckets}} 
</table>


<table width=100% border=1>
<tr>
 <th> LotNumber </th>
 <th> TOperation </th>
 <th> TestCode </th>
</tr>
{{#response.hits.hits}} 
<tr>
 <td> {{_source.LotNumber}} </td>
 <td> {{_source.Operation}} </td>
 <td> {{_source.TestCode}} </td>
 
</tr>
{{/response.hits.hits}} 
</table>
<pre>
{{meta.debug}}
</pre>

<hr>


example 2 lot:
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "Operation": {
              "value": "FT"
            }
          }
        },
        {
          "terms": {
            "LotNumber": [
              "HG50212",
              "HG50215"
            ]
          }
        },
        {
          "term": {
            "Type": {
              "value": "PinMeasure"
            }
          }
        },
        {
          "term": {
            "Pin": {
              "value": "S_VDDCR_SOC"
            }
          }
        }
      ],
      "filter": {
        "terms": {
          "context": [
            "Sidd_VddCrSoc_V1",
            "Sidd_VddCrSoc_V3"
          ]
        }
      }
    }
  },
  "size": 0,
  "aggs": {
    "LotNumber": {
      "terms": {
        "field": "LotNumber",
        "size": 2
      },
      "aggs": {
        "UnitId": {
          "terms": {
            "field": "UnitId",
            "size": 5000
          },
          "aggs": {
            "TestName": {
              "terms": {
                "field": "context"
              },
              "aggs": {
                "Avg": {
                  "avg": {
                    "field": "value"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//js

({
  after_render: function() {
    
    var svgViewport = d3.select("#viz")
        .append("svg")
        .attr("width",800)
        .attr("height",600);

    var margin = {top: 80, right: 50, bottom: 50, left: 75},
        width  = 800 - margin.left - margin.right,           
        height = 600 - margin.top  - margin.bottom;

    var innerSpace = svgViewport.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
    // define the data
    var lot_data_0 = response.aggregations.LotNumber.buckets[0].UnitId.buckets;
    var lot_data_1 = response.aggregations.LotNumber.buckets[1].UnitId.buckets;
    
    var a = lot_data_0;
    var b = lot_data_1;
    
    /*
    var a  = response.aggregations.UnitId.buckets;
    var minX = d3.min(a, function(d, i) { return a[i].TestName.buckets[0].Avg.value; });
    var maxX = d3.max(a, function(d, i) { return a[i].TestName.buckets[0].Avg.value; });
    var minY = d3.min(a, function(d, i) { return a[i].TestName.buckets[1].Avg.value; });
    var maxY = d3.max(a, function(d, i) { return a[i].TestName.buckets[1].Avg.value; });
    */
    
    // sort lot_data_0
    var minX_0 = d3.min(lot_data_0, function(d, i) { return lot_data_0[i].TestName.buckets[0].Avg.value; });
    var maxX_0 = d3.max(lot_data_0, function(d, i) { return lot_data_0[i].TestName.buckets[0].Avg.value; });
   
    var minY_0 = d3.min(lot_data_0, function(d, i) { return lot_data_0[i].TestName.buckets[1].Avg.value; });
    var maxY_0 = d3.max(lot_data_0, function(d, i) { return lot_data_0[i].TestName.buckets[1].Avg.value; });
    
    // sort lot_data_1
    var minX_1 = d3.min(lot_data_1, function(d, i) { return lot_data_1[i].TestName.buckets[0].Avg.value; });
    var maxX_1 = d3.max(lot_data_1, function(d, i) { return lot_data_1[i].TestName.buckets[0].Avg.value; });
   
    var minY_1 = d3.min(lot_data_1, function(d, i) { return lot_data_1[i].TestName.buckets[1].Avg.value; });
    var maxY_1 = d3.max(lot_data_1, function(d, i) { return lot_data_1[i].TestName.buckets[1].Avg.value; });
    
      
    // sort all data here
    var minX = minX_0 > minX_1 ? minX_1 : minX_0;
    var maxX = maxX_0 > maxX_1 ? maxX_0 : maxX_1;
    
    var minY = minY_0 > minY_1 ? minY_1 : minY_0;
    var maxY = maxY_0 > maxY_1 ? maxY_0 : maxY_1;
   
   
   console.log("minX = " + minX);
   console.log("maxX = " + maxX);
   
   console.log("minY = " + minY);
   console.log("maxY = " + maxY);  
   
    // 1) change the scale
    var xAxisScale = d3.scale.linear()
        .domain([minX, maxX])
        .range( [0, width])
        .nice();
    
    var yAxisScale = d3.scale.linear()
    .domain([minY, maxY])
    .range( [height, 0])
    .nice();
        
    // 2) redefine the axis
   
    var myXAxis = d3.svg.axis().scale(xAxisScale).orient("bottom");
    var myYAxis = d3.svg.axis().scale(yAxisScale).orient("left");
    
    // 3) redraw the axis
    var axisXGroup = innerSpace.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(myXAxis);
    
    var axisYGroup = innerSpace.append("g")
    .attr("class", "y axis")
    .call(myYAxis);
    
    
    innerSpace.selectAll("scatter_lot_0")
    .data(lot_data_0)
    .enter()
    .append("circle") 
        .style("stroke", "gray") 
        .style("fill", "red")
        .attr("r", function(d, i){
            return 3 ;
        })
        .attr("cx", function(d, i){
            return xAxisScale(lot_data_0[i].TestName.buckets[0].Avg.value);
        })
        .attr("cy",  function(d, i){
            return yAxisScale(lot_data_0[i].TestName.buckets[1].Avg.value);
        })
        .on("mouseover", function(d,i){
            d3.select(this).style("fill", "green");
            var str ="UnitID = " +  lot_data_0[i].key + ", "
            + lot_data_0[i].TestName.buckets[0].key + " = " + lot_data_0[i].TestName.buckets[0].Avg.value + ", "
            + lot_data_0[i].TestName.buckets[1].key + " = " + lot_data_0[i].TestName.buckets[1].Avg.value;
            //d3.select(".chart-header").text(JSON.stringify(this, null, ' '));
            d3.select(".chart-header").text(str);
            
        })
        .on("mouseout", function(){d3.select(this).style("fill", "red");
             d3.select(".chart-header").text("");
        });
        
    var opacity_1 = 0.1;
    
    innerSpace.selectAll("scatter_lot_1")
    .data(lot_data_1)
    .enter()
    .append("circle") 
        .style("stroke", "gray") 
        .style("fill", "blue")
        .style("opacity", opacity_1)
        .attr("r", function(d, i){
            return 3 ;
        })
        .attr("cx", function(d, i){
            return xAxisScale(lot_data_1[i].TestName.buckets[0].Avg.value);
        })
        .attr("cy",  function(d, i){
            return yAxisScale( lot_data_1[i].TestName.buckets[1].Avg.value);
        })
        .on("mouseover", function(d,i){
            d3.select(this).style("fill", "green");
            var str ="UnitID = " +  lot_data_1[i].key + ", "
            + lot_data_1[i].TestName.buckets[0].key + " = " + lot_data_1[i].TestName.buckets[0].Avg.value + ", "
            + lot_data_1[i].TestName.buckets[1].key + " = " + lot_data_1[i].TestName.buckets[1].Avg.value;
            //d3.select(".chart-header").text(JSON.stringify(this, null, ' '));
            d3.select(".chart-header").text(str);
            d3.select(this)
                .transition()
                .style("opacity",1);
            
        })
        .on("mouseout", function(){d3.select(this).style("fill", "blue");
             d3.select(".chart-header").text("");
             opacity_1 = 0.1;
        });
        
    innerSpace.selectAll("scatter_lot_1")
    .data(lot_data_1)
    .exit()
    .remove();
    
    innerSpace.selectAll("scatter_lot_0")
    .data(lot_data_0)
    .exit()
    .remove();
        
    innerSpace.append("text")
      .attr("transform", "translate(0,-10)")
      .text("title")
      .classed("chart-header", true)
      .attr("x", 0)
      .attr("y", -50);
      
      
/*      
    var jsonCircles = [ { "x_axis": 30, "y_axis": 30, "radius": 20, "color" : "green" },
    { "x_axis": 70, "y_axis": 70, "radius": 20, "color" : "purple"},
    { "x_axis": 110, "y_axis": 100, "radius": 20, "color" : "red"}];
    

 var circles = svgContainer.selectAll("circle")
    .data(jsonCircles)
    .enter()
    .append("circle");



var circleAttributes = circles
    .attr("cx", function (d) { return d.x_axis; })
    .attr("cy", function (d) { return d.y_axis; })
    .attr("r", function (d) { return d.radius; })
    .style("fill", function(d) { return d.color; });
*/
    
  },
  count_hits: function() {
  return this.response.hits.hits.length;
 },
 count_aggs: function() {
     var a  = response.aggregations.UnitId.buckets;
     return a[0].TestName.buckets[0].Avg.value;
 },
  all_aggs: function() {
     var a = this.response.aggregations.UnitId.buckets;
     return a;
 },
 debug: function() {
  return JSON.stringify(this, null, ' ');
 } 
})

//template

<div id="viz"> </div>
<pre>
{{meta.debug}}
</pre>



3: 
js

({
  after_render: function() {
    
    var svgViewport = d3.select("#viz")
        .append("svg")
        .attr("width",800)
        .attr("height",600);

    var margin = {top: 80, right: 50, bottom: 50, left: 75},
        width  = 800 - margin.left - margin.right,           
        height = 600 - margin.top  - margin.bottom;

    var innerSpace = svgViewport.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
    // define the data
    var all_data = response.aggregations.LotNumber.buckets;
    var lot_data_0 = response.aggregations.LotNumber.buckets[0].UnitId.buckets;
    var lot_data_1 = response.aggregations.LotNumber.buckets[1].UnitId.buckets;
    
    var a = lot_data_0;
    var b = lot_data_1;
    
    /*
    var a  = response.aggregations.UnitId.buckets;
    var minX = d3.min(a, function(d, i) { return a[i].TestName.buckets[0].Avg.value; });
    var maxX = d3.max(a, function(d, i) { return a[i].TestName.buckets[0].Avg.value; });
    var minY = d3.min(a, function(d, i) { return a[i].TestName.buckets[1].Avg.value; });
    var maxY = d3.max(a, function(d, i) { return a[i].TestName.buckets[1].Avg.value; });
    */
    
    // sort lot_data_0
    var minX_0 = d3.min(lot_data_0, function(d, i) { return lot_data_0[i].TestName.buckets[0].Avg.value; });
    var maxX_0 = d3.max(lot_data_0, function(d, i) { return lot_data_0[i].TestName.buckets[0].Avg.value; });
   
    var minY_0 = d3.min(lot_data_0, function(d, i) { return lot_data_0[i].TestName.buckets[1].Avg.value; });
    var maxY_0 = d3.max(lot_data_0, function(d, i) { return lot_data_0[i].TestName.buckets[1].Avg.value; });
    
    // sort lot_data_1
    var minX_1 = d3.min(lot_data_1, function(d, i) { return lot_data_1[i].TestName.buckets[0].Avg.value; });
    var maxX_1 = d3.max(lot_data_1, function(d, i) { return lot_data_1[i].TestName.buckets[0].Avg.value; });
   
    var minY_1 = d3.min(lot_data_1, function(d, i) { return lot_data_1[i].TestName.buckets[1].Avg.value; });
    var maxY_1 = d3.max(lot_data_1, function(d, i) { return lot_data_1[i].TestName.buckets[1].Avg.value; });
    
      
    // sort all data here
    var minX = minX_0 > minX_1 ? minX_1 : minX_0;
    var maxX = maxX_0 > maxX_1 ? maxX_0 : maxX_1;
    
    var minY = minY_0 > minY_1 ? minY_1 : minY_0;
    var maxY = maxY_0 > maxY_1 ? maxY_0 : maxY_1;
   
   
   console.log("minX = " + minX);
   console.log("maxX = " + maxX);
   
   console.log("minY = " + minY);
   console.log("maxY = " + maxY);  
   
   // color 
   //var colorScale = d3.scaleOrdinal(d3.schemeCategory10);
   var color = d3.scale.linear().domain([1,3])
      .interpolate(d3.interpolateHcl)
      .range([d3.rgb("#007AFF"), d3.rgb('#FFF500')]);
    
    color = d3.scale.linear()
        .domain([0, 1])
        .range(["red", "green", "blue"]);
    
    
    // 1) change the scale
    var xAxisScale = d3.scale.linear()
        .domain([minX, maxX])
        .range( [0, width])
        .nice();
    
    var yAxisScale = d3.scale.linear()
    .domain([minY, maxY])
    .range( [height, 0])
    .nice();
        
    // 2) redefine the axis
   
    var myXAxis = d3.svg.axis().scale(xAxisScale).orient("bottom");
    var myYAxis = d3.svg.axis().scale(yAxisScale).orient("left");
    
    // 3) redraw the axis
    var axisXGroup = innerSpace.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(myXAxis);
    
    var axisYGroup = innerSpace.append("g")
    .attr("class", "y axis")
    .call(myYAxis);
    
    
    // plot

    var self = innerSpace;
    //enter() for <g>
    innerSpace.selectAll(".lot")
        .data(all_data)
        .enter()
        .append("g")
        .attr("class", function(d, i){
         return all_data[i].key;
        })
        .classed("lot", true)
        .style("opacity", 0.1);
  
    //update for <g>
    innerSpace.selectAll(".lot")
        .style("fill", function(d,i){
            return color(i);
        })
        .on("mouseover", function(d,i){
            d3.select(this)
                .transition()
                .style("opacity",1);
        })
        .on("mouseout", function(d,i){
            d3.select(this)
                .transition()
                .style("opacity",0.3);
      })
      
      //exit() for <g>
      /*
      innerSpace.selectAll(".lot")
        .exit()
        .remove();
        */
    all_data.forEach(function(lot){
        var g = self.selectAll("g." + lot.key);
        var data = lot.UnitId.buckets;
        
        g.selectAll(".data")
            .data(data)
            .enter()
            .append("circle")
            .classed("response", true)
        
        //update
        g.selectAll(".response")
            .attr("r", function(d, i){
                return 3 ;
            })
            .attr("cx", function(d, i){
                return xAxisScale(data[i].TestName.buckets[0].Avg.value);
            })
            .attr("cy",  function(d, i){
                return yAxisScale(data[i].TestName.buckets[1].Avg.value);
            })
            .on("mouseover", function(d,i){
                var str ="UnitID = " +  data[i].key + ", "
                + data[i].TestName.buckets[0].key + " = " + data[i].TestName.buckets[0].Avg.value + ", "
                + data[i].TestName.buckets[1].key + " = " + data[i].TestName.buckets[1].Avg.value;
                //d3.select(".chart-header").text(JSON.stringify(this, null, ' '));
                d3.select(".chart-header").text(str);
            })
            .on("mouseout", function(d,i){
                d3.select(".chart-header").text("")
            })
        //exit()
        g.selectAll(".response")
          .data(data)
          .exit()
          .remove();
    })
    
    
    
    
    
    /*
    innerSpace.selectAll("scatter_lot_0")
    .data(lot_data_0)
    .enter()
    .append("circle") 
        .style("stroke", "gray") 
        .style("fill", "red")
        .attr("r", function(d, i){
            return 3 ;
        })
        .attr("cx", function(d, i){
            return xAxisScale(lot_data_0[i].TestName.buckets[0].Avg.value);
        })
        .attr("cy",  function(d, i){
            return yAxisScale(lot_data_0[i].TestName.buckets[1].Avg.value);
        })
        .on("mouseover", function(d,i){
            d3.select(this).style("fill", "green");
            var str ="UnitID = " +  lot_data_0[i].key + ", "
            + lot_data_0[i].TestName.buckets[0].key + " = " + lot_data_0[i].TestName.buckets[0].Avg.value + ", "
            + lot_data_0[i].TestName.buckets[1].key + " = " + lot_data_0[i].TestName.buckets[1].Avg.value;
            //d3.select(".chart-header").text(JSON.stringify(this, null, ' '));
            d3.select(".chart-header").text(str);
            
        })
        .on("mouseout", function(){d3.select(this).style("fill", "red");
             d3.select(".chart-header").text("");
        });
        
    var opacity_1 = 0.1;
    
    innerSpace.selectAll("scatter_lot_1")
    .data(lot_data_1)
    .enter()
    .append("circle") 
        .style("stroke", "gray") 
        .style("fill", "blue")
        .style("opacity", opacity_1)
        .attr("r", function(d, i){
            return 3 ;
        })
        .attr("cx", function(d, i){
            return xAxisScale(lot_data_1[i].TestName.buckets[0].Avg.value);
        })
        .attr("cy",  function(d, i){
            return yAxisScale( lot_data_1[i].TestName.buckets[1].Avg.value);
        })
        .on("mouseover", function(d,i){
            d3.select(this).style("fill", "green");
            var str ="UnitID = " +  lot_data_1[i].key + ", "
            + lot_data_1[i].TestName.buckets[0].key + " = " + lot_data_1[i].TestName.buckets[0].Avg.value + ", "
            + lot_data_1[i].TestName.buckets[1].key + " = " + lot_data_1[i].TestName.buckets[1].Avg.value;
            //d3.select(".chart-header").text(JSON.stringify(this, null, ' '));
            d3.select(".chart-header").text(str);
            d3.select(this)
                .transition()
                .style("opacity",1);
            
        })
        .on("mouseout", function(){d3.select(this).style("fill", "blue");
             d3.select(".chart-header").text("");
             opacity_1 = 0.1;
        });
        
    innerSpace.selectAll("scatter_lot_1")
    .data(lot_data_1)
    .exit()
    .remove();
    
    innerSpace.selectAll("scatter_lot_0")
    .data(lot_data_0)
    .exit()
    .remove();
        
    innerSpace.append("text")
      .attr("transform", "translate(0,-10)")
      .text("title")
      .classed("chart-header", true)
      .attr("x", 0)
      .attr("y", -50);
    */  
      
/*      
    var jsonCircles = [ { "x_axis": 30, "y_axis": 30, "radius": 20, "color" : "green" },
    { "x_axis": 70, "y_axis": 70, "radius": 20, "color" : "purple"},
    { "x_axis": 110, "y_axis": 100, "radius": 20, "color" : "red"}];
    

 var circles = svgContainer.selectAll("circle")
    .data(jsonCircles)
    .enter()
    .append("circle");



var circleAttributes = circles
    .attr("cx", function (d) { return d.x_axis; })
    .attr("cy", function (d) { return d.y_axis; })
    .attr("r", function (d) { return d.radius; })
    .style("fill", function(d) { return d.color; });
*/
    
  },
  count_hits: function() {
  return this.response.hits.hits.length;
 },
 count_aggs: function() {
     var a  = response.aggregations.UnitId.buckets;
     return a[0].TestName.buckets[0].Avg.value;
 },
  all_aggs: function() {
     var a = this.response.aggregations.UnitId.buckets;
     return a;
 },
 debug: function() {
  return JSON.stringify(this, null, ' ');
 } 
})


example4:

dsl:
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "Operation": {
              "value": "FT"
            }
          }
        },
        {
          "terms": {
            "LotNumber": [
              "HG50212",
              "HG50215"
            ]
          }
        },
        {
          "term": {
            "Type": {
              "value": "PinMeasure"
            }
          }
        },
        {
          "term": {
            "Pin": {
              "value": "S_VDDCR_SOC"
            }
          }
        }
      ],
      "filter": {
        "terms": {
          "context": [
            "Sidd_VddCrSoc_V1",
            "Sidd_VddCrSoc_V3"
          ]
        }
      }
    }
  },
  "size": 0,
  "aggs": {
    "LotNumber": {
      "terms": {
        "field": "LotNumber",
        "size": 2
      },
      "aggs": {
        "UnitId": {
          "terms": {
            "field": "UnitId",
            "size": 5000
          },
          "aggs": {
            "TestName": {
              "terms": {
                "field": "context"
              },
              "aggs": {
                "Avg": {
                  "avg": {
                    "field": "value"
                  }
                }
              }
            }
          }
        }
      }
    },
    "Helper":{
      "terms": {
        "field": "context",
        "size": 10
      },
      "aggs": {
        "max": {
          "max": {
            "field": "value"
          }
        },
        "min":{
          "min": {
            "field": "value"
          }
          
        }
      }
      
    }

    
  }
}


js:

({
  after_render: function() {
    
    var panelWidth = 800;
    var panelHeight = 600;
    
    
    var ob = document.getElementById("viz");
    if(ob !== null){
        panelHeight = ob.offsetHeight - 50; 
        panelWidth = ob.offsetWidth - 50;
        console.log("height = " + panelHeight);
        console.log("widht = " + panelWidth);
    }
   
    var svgViewport = d3.select("#viz")
        .append("svg")
        .attr("width",panelWidth)
        .attr("height",panelHeight);

    var margin = {top: 80, right: 50, bottom: 50, left: 75},
        width  = panelWidth - margin.left - margin.right,           
        height = panelHeight - margin.top  - margin.bottom;
        
        console.log("svg width = " + width);
        console.log("sg height = " + height);

    var innerSpace = svgViewport.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
    // define the data
    var all_data = response.aggregations.LotNumber.buckets;
    var lot_data_0 = response.aggregations.LotNumber.buckets[0].UnitId.buckets;
    var lot_data_1 = response.aggregations.LotNumber.buckets[1].UnitId.buckets;
    
    var a = lot_data_0;
    var b = lot_data_1;
    
    var minX = 0;
    var minY = 0;
    var maxX = 0;
    var maxY = 0;
    
    
    minX = response.aggregations.Helper.buckets[0].min.value;
    maxX = response.aggregations.Helper.buckets[0].max.value;
    
    minY = response.aggregations.Helper.buckets[1].min.value;
    maxY = response.aggregations.Helper.buckets[1].max.value;
   
    console.log("minX = " + minX);
    console.log("maxX = " + maxX);
   
    console.log("minY = " + minY);
    console.log("maxY = " + maxY);  
   
    // color 
    //var colorScale = d3.scaleOrdinal(d3.schemeCategory10);
    var color = d3.scale.linear().domain([1,3])
      .interpolate(d3.interpolateHcl)
      .range([d3.rgb("#007AFF"), d3.rgb('#FFF500')]);
    
    color = d3.scale.linear()
        .domain([0, all_data.length])
        .range(["red", "green"]);
    color = d3.scale.category10(); 
    console.log(d3.scale.category10().length);
    
    // 1) change the scale
    var xAxisScale = d3.scale.linear()
        .domain([minX, maxX])
        .range( [0, width])
        .nice();
    
    var yAxisScale = d3.scale.linear()
    .domain([minY, maxY])
    .range( [height, 0])
    .nice();
        
    // 2) redefine the axis
   
    var myXAxis = d3.svg.axis().scale(xAxisScale).orient("bottom");
    var myYAxis = d3.svg.axis().scale(yAxisScale).orient("left");
    
    // 3) redraw the axis
    var axisXGroup = innerSpace.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(myXAxis);
    
    var axisYGroup = innerSpace.append("g")
    .attr("class", "y axis")
    .call(myYAxis);
    
    
    // plot

    var self = innerSpace;
    //enter() for <g>
    innerSpace.selectAll(".lot")
        .data(all_data)
        .enter()
        .append("g")
        .attr("class", function(d, i){
         return all_data[i].key;
        })
        .classed("lot", true)
        .style("opacity", 0.3);
  
    //update for <g>
    innerSpace.selectAll(".lot")
        .style("fill", function(d,i){
            return color(i);
        })
        .on("mouseover", function(d,i){
            d3.select(this)
                .transition()
                .style("opacity",1);
        })
        .on("mouseout", function(d,i){
            d3.select(this)
                .transition()
                .style("opacity",0.3);
      })
      
      //exit() for <g>
      /*
      innerSpace.selectAll(".lot")
        .exit()
        .remove();
        */
    all_data.forEach(function(lot){
        var g = self.selectAll("g." + lot.key);
        var data = lot.UnitId.buckets.filter(function (d){
            return d.TestName.buckets.length === 2;
            
        });
        
        g.selectAll(".data")
            .data(data)
            .enter()
            .append("circle")
            .classed("response", true)
        
        //update
        g.selectAll(".response")
            .attr("r", function(d, i){
                return 3 ;
            })
            .attr("cx", function(d, i){
                return xAxisScale(data[i].TestName.buckets[0].Avg.value);
            })
            .attr("cy",  function(d, i){
                return yAxisScale(data[i].TestName.buckets[1].Avg.value);
            })
            .on("mouseover", function(d,i){
                var str = "LotNumber = " + lot.key + ", "
                + "UnitID = " +  data[i].key + ", "
                
                //+ data[i].TestName.buckets[0].key + " = " + data[i].TestName.buckets[0].Avg.value + ", "
                //+ data[i].TestName.buckets[1].key + " = " + data[i].TestName.buckets[1].Avg.value
                
                + "x = " + data[i].TestName.buckets[0].Avg.value + ", "
                + "y = " + data[i].TestName.buckets[1].Avg.value
                
                ;
                d3.select(".chart-header").text(str);
            })
            .on("mouseout", function(d,i){
                d3.select(".chart-header").text("")
            })
        //exit()
        g.selectAll(".response")
          .data(data)
          .exit()
          .remove();
    }),
    
    innerSpace.append("text")
      .attr("transform", "translate(0,-10)")
      .text("")
      .classed("chart-header", true)
      .attr("x", 50)
      .attr("y", -10);
    
    innerSpace.select(".x.axis")
      .append("text")
      .classed("x axis-label", true)
      .attr("transform","translate("+ width/2  + ",48)")
      .style("fill","black")
      .text(response.aggregations.Helper.buckets[0].key);
    
    innerSpace.select(".y.axis")
      .append("text")
      .classed("y axis-label",true)
      .style("fill","black")
      .attr("transform","translate(" + -56 + "," + height/2 + ") rotate(-90)")
      .text(response.aggregations.Helper.buckets[1].key);
    
  },
  count_hits: function() {
  return this.response.hits.hits.length;
 },
 count_aggs: function() {
     var a  = response.aggregations.UnitId.buckets;
     return a[0].TestName.buckets[0].Avg.value;
 },
  all_aggs: function() {
     var a = this.response.aggregations.UnitId.buckets;
     return a;
 },
 debug: function() {
  return JSON.stringify(this, null, ' ');
 } 
})

template:

<div id="viz" style="color:blue; text-align:center; margin:0 auto;position: absolute;bottom: 0;top: 0; left:0; right: 0; font-size: 15px">

</div>


// boxplot demo
{
    "sort": [
        {
          "LotNumber": {
            "order": "desc"
          }
        },
        {
          "context": {
            "order": "asc"
          }
        }
  ],
   "query": {
    "bool": {
      "must": [
        {
          "term": {
            "Operation": {
              "value": "FT"
            }
          }
        },
        {
          "terms": {
            "LotNumber": [
              "HG50212",
              "HG50215",
              "HG00057E"
            ]
          }
        },
        {
          "term": {
            "Type": {
              "value": "PinMeasure"
            }
          }
        },
        {
          "term": {
            "Pin": {
              "value": "S_VDDCR_SOC"
            }
          }
        }
      ],
      "filter": {
        "terms": {
          "context": [
            "Sidd_VddCrSoc_V1",
            "Sidd_VddCrSoc_V2",
            "Sidd_VddCrSoc_V3"
          ]
        }
      }
    }
  },
  "size": 10000,
  "_source": ["context", "LotNumber", "value"]
}


({
    /*
    * please never try edit the js code
     ****************************************************************
     *  author: guanghao                                            *
     *  description: box plot chart                                 *
     *  the x is defined as the context name, that is the series    *
     *  the y is defined as the test value, that is the group       *
     *  limitation: max data size is 10000                          *
     ****************************************************************
     * how to edit the Query DSL?
     * 1) modify the 'Operation' field if needed
     * 2) modify the 'LotNumber' field to your target lot
     * 3) modify the 'Type' field if needed
     * 4) modify the 'Pin' field if needed
     * 5) filter the test flow context
     */
    
    after_render: function() {
        var all_data = response.hits.hits;
        /****/
        var y = [];
        var x = [];
        
        var lots = [];
        let no = 0;
        
        all_data.forEach(function(hit){
            var lotNumber = hit._source.LotNumber;
            var curr_lot = lots.find(function(lot){
               return lot.lotNumber === lotNumber;
            });
            
            if (curr_lot == null) {
                no = lots.length;
                curr_lot = {lotNumber: lotNumber,  x: [],  y: [] };
                lots[no] = curr_lot;
            }
            var y = curr_lot.y;
            var x = curr_lot.x;
            no = y.length;
            y[no] = hit._source.value;
            x[no] = hit._source.context;
        });
        
        console.log(lots);
        
        var traces = [];
        no = 0;
        lots.forEach(function(lot){
            var trace = {
              y: lot.y,
              x: lot.x,
              name: lot.lotNumber,
              marker: {color: d3.scale.category10[no]},
              type: 'box'
            };
            traces[no] = trace;
            no ++;
            
        });
        var layout = {
          title: 'Sidd Distribution',
          yaxis: {
            title: 'test value',
            zeroline: false
          },
          boxmode: 'group'
        };
        
        Plotly.newPlot('myDiv', traces, layout);
        
    }
})



<div id="myDiv" style="color:blue; text-align:center; margin:0 auto;position: absolute;bottom: 0;top: 0; left:0; right: 0; font-size: 15px">
    
</div>


spc-chart-demo

{
  "sort": [
    {
      "LotEndTime": {
        "order": "asc"
      }
    }
  ], 
  "query": {
       
    "bool": {
      "must": [
        {
          "terms": {
            "Operation": [
              "FT",
              "FT2"
            ]
          }
        }
      ],
      "filter": {
        "range": {
          "LotEndTime": {
             "gte" : "now-50d/d",
              "lt" :  "now/d"
          }
        }
      }
    }
  },
  "_source": ["LotNumber", "LotEndTime", "kdfFinalYield"],
  "size" : 500
}




({
    
    // This is to install external script/library
    import_funnelLib_plotly: function() {
         $.getScript("https://cdn.plot.ly/plotly-latest.min.js", function( data, textStatus, jqxhr ) {
            console.log("Import Complete");
        }); 
    },
    
 
    after_render: function() {
        var loLimit = 0.9;
        
        var lots = response.hits.hits;
        var x =[];
        var y = [];
        var ucl = [];
        let i = 0;
        lots.forEach(function(lot){
            x[i] = lot._source.LotNumber;
            y[i] = lot._source.kdfFinalYield;
            ucl[i] = loLimit;
            i++;
        });
        console.log(x);
        var Data = {
          type: 'scatter',
          x: x,
          y: y,
          mode: 'lines+markers',
          name: 'Data',
          showlegend: true,
          hoverinfo: 'all',
          line: {
            color: 'green',
            width: 2
          },
          marker: {
            color: 'green',
            size: 8,
            symbol: 'circle'
          }
        }
        
        var Viol = {
          type: 'scatter',
          x: [6,9],
          y: [-7,8],
          mode: 'markers',
          name: 'Violation',
          showlegend: true,
          marker: {
            color: 'rgb(255,65,54)',
            line: {width: 3},
            opacity: 0.5,
            size: 12,
            symbol: 'circle-open'
          }
        }
        
        var LCL = {
          type: 'scatter',
          x: [0, 10],
          y: [-5, -5],
          mode: 'lines',
          name: 'LCL',
          showlegend: true,
          line: {
            color: 'red',
            width: 2,
            dash: 'dash'
          }
        }
        var UCL = {
          type: 'scatter',
          x: x,
          y: ucl,
          mode: 'lines',
          name: 'UCL',
          showlegend: true,
          line: {
            color: 'red',
            width: 2,
            dash: 'dash'
          }
        }
        
        var Centre = {
          type: 'scatter',
          x: [0.5, 20],
          y: [0, 0],
          mode: 'lines',
          name: 'Centre',
          showlegend: true,
          line: {
            color: 'grey',
            width: 2
          }
        }
        
        var histo = {
          type: 'histogram',
          orientation: 'h',
          x: y,
          y: y,
          name: 'Distribution',   
          marker: {
            color: 'green',
            line: {
              color: 'white',
              width: 1
            }
          },
          xaxis: 'x2',
          yaxis: 'y'
        }
        var data = [Data, UCL, histo]
        //var data = [Viol,UCL, Centre,histo]
        
        // layout
        var layout = {
          title: 'Yield SPC Chart',
          xaxis: {
            domain: [0, 0.7], // 0 to 70% of width
            zeroline: false
          },
          yaxis: {
            //range: [0.8,1],
            zeroline: false
          },
          xaxis2: {
            domain: [0.7, 1] // 70 to 100% of width
          }
        }
        
        Plotly.plot('myDiv', data,layout);
    },
    count_hits: function() {
            return this.response.hits.hits.length;
    },
    count_aggs: function() {
        var a  = response.aggregations.UnitId.buckets;
        return a[0].TestName.buckets[0].Avg.value;
    },
    all_aggs: function() {
        var a = this.response.aggregations.UnitId.buckets;
        return a;
    },
    debug: function() {
        return JSON.stringify(this, null, ' ');
    } 
})


<div id="myDiv" style="color:blue; text-align:center; margin:0 auto;position: absolute;bottom: 0;top: 0; left:0; right: 0; font-size: 15px">
    
</div>

boxplot-raw

{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "Operation": {
              "value": "FT"
            }
          }
        },
        {
          "terms": {
            "LotNumber": [
              "HG50212",
              "HG50215",
              "HG00057E"
            ]
          }
        },
        {
          "term": {
            "Type": {
              "value": "PinMeasure"
            }
          }
        },
        {
          "term": {
            "Pin": {
              "value": "S_VDDCR_SOC"
            }
          }
        }
      ],
      "filter": {
        "terms": {
          "context": [
            "Sidd_VddCrSoc_V1",
            "Sidd_VddCrSoc_V2",
            "Sidd_VddCrSoc_V3"
          ]
        }
      }
    }
  },
  "size": 10000,
  "_source": ["context", "LotNumber", "value"]
}



({
    
    // This is to install external script/library
    import_funnelLib_plotly: function() {
         $.getScript("https://cdn.plot.ly/plotly-latest.min.js", function( data, textStatus, jqxhr ) {
            console.log("Import Complete");
        }); 
    },
    
 
   after_render: function() {
       var xData = ['Carmelo<br>Anthony', 'Dwyane<br>Wade',
      'Deron<br>Williams', 'Brook<br>Lopez',
      'Damian<br>Lillard', 'David<br>West',
      'Blake<br>Griffin', 'David<br>Lee',
      'Demar<br>Derozan'];
      
        function getrandom(num , mul) 
        {
           var value = [ ]  
            for(i=0;i<=num;i++)
           {
             var rand=Math.random() * mul;
            value.push(rand);
            }
            return value
        }
        var yData = [
           getrandom(30 ,10),
            getrandom(30, 20),
           getrandom(30, 25),
           getrandom(30, 40),
            getrandom(30, 45),
           getrandom(30, 30),
           getrandom(30, 20),
           getrandom(30, 15),
           getrandom(30, 43)
        ];
        
        var colors = ['rgba(93, 164, 214, 0.5)', 'rgba(255, 144, 14, 0.5)', 'rgba(44, 160, 101, 0.5)', 'rgba(255, 65, 54, 0.5)', 'rgba(207, 114, 255, 0.5)', 'rgba(127, 96, 0, 0.5)', 'rgba(255, 140, 184, 0.5)', 'rgba(79, 90, 117, 0.5)', 'rgba(222, 223, 0, 0.5)'];
        
        var data = [];
        
        for ( var i = 0; i < xData.length; i ++ ) {
          var result = {
            type: 'box',
            y: yData[i],
            name: xData[i],
            boxpoints: 'all',
            jitter: 0.5,
            whiskerwidth: 0.2,
            fillcolor: 'cls',
            marker: {
              size: 2
            },
            line: {
              width: 1
            }
          };
          data.push(result);
        }
        
        var layout = {
            title: 'Points Scored by the Top 9 Scoring NBA Players in 2012',
            yaxis: {
                autorange: true,
                showgrid: true,
                zeroline: true,
                dtick: 5,
                gridcolor: 'rgb(255, 255, 255)',
                gridwidth: 1,
                zerolinecolor: 'rgb(255, 255, 255)',
                zerolinewidth: 2
            },
            margin: {
                l: 40,
                r: 30,
                b: 80,
                t: 100
            },
            paper_bgcolor: 'rgb(243, 243, 243)',
            plot_bgcolor: 'rgb(243, 243, 243)',
            showlegend: false
        };
    
    Plotly.newPlot('myDiv', data, layout, {showSendToCloud: true});
    
  },
  count_hits: function() {
  return this.response.hits.hits.length;
 },
 count_aggs: function() {
     var a  = response.aggregations.UnitId.buckets;
     return a[0].TestName.buckets[0].Avg.value;
 },
  all_aggs: function() {
     var a = this.response.aggregations.UnitId.buckets;
     return a;
 },
 debug: function() {
  return JSON.stringify(this, null, ' ');
 } 
})


<div id="myDiv" style="color:blue; text-align:center; margin:0 auto;position: absolute;bottom: 0;top: 0; left:0; right: 0; font-size: 15px">
    
</div>



plotly-scatter

{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "Operation": {
              "value": "FT"
            }
          }
        },
        {
          "terms": {
            "LotNumber": [
              "HG50212",
              "HG50215"
            ]
          }
        },
        {
          "term": {
            "Type": {
              "value": "PinMeasure"
            }
          }
        },
        {
          "term": {
            "Pin": {
              "value": "S_VDDCR_SOC"
            }
          }
        }
      ],
      "filter": {
        "terms": {
          "context": [
            "Sidd_VddCrSoc_V1",
            "Sidd_VddCrSoc_V3"
          ]
        }
      }
    }
  },
  "size": 0,
  "aggs": {
    "LotNumber": {
      "terms": {
        "field": "LotNumber",
        "size": 2
      },
      "aggs": {
        "UnitId": {
          "terms": {
            "field": "UnitId",
            "size": 5000
          },
          "aggs": {
            "TestName": {
              "terms": {
                "field": "context"
              },
              "aggs": {
                "Avg": {
                  "avg": {
                    "field": "value"
                  }
                }
              }
            }
          }
        }
      }
    },
    "Helper":{
      "terms": {
        "field": "context",
        "size": 10
      },
      "aggs": {
        "max": {
          "max": {
            "field": "value"
          }
        },
        "min":{
          "min": {
            "field": "value"
          }
          
        }
      }
      
    }

    
  }
}


({
    
    // This is to install external script/library
    import_funnelLib: function() {
        // $.getScript("https://canvasjs.com/assets/script/jquery.canvasjs.min.js", function( data, textStatus, jqxhr ) {
        //    console.log("Import Complete");
        //}); 
    },
 
   after_render: function() {
    
    var panelWidth = 800;
    var panelHeight = 600;
    
    
    var ob = document.getElementById("viz");
    if(ob !== null){
        panelHeight = ob.offsetHeight - 50; 
        panelWidth = ob.offsetWidth - 50;
        console.log("height = " + panelHeight);
        console.log("widht = " + panelWidth);
    }
   
    
    
    // define the data
    var all_data = response.aggregations.LotNumber.buckets;
    var lot_data_0 = response.aggregations.LotNumber.buckets[0].UnitId.buckets;
    var lot_data_1 = response.aggregations.LotNumber.buckets[1].UnitId.buckets;
    
    var a = lot_data_0;
    var b = lot_data_1;
    
    var minX = 0;
    var minY = 0;
    var maxX = 0;
    var maxY = 0;
    
    
    minX = response.aggregations.Helper.buckets[0].min.value;
    maxX = response.aggregations.Helper.buckets[0].max.value;
    
    minY = response.aggregations.Helper.buckets[1].min.value;
    maxY = response.aggregations.Helper.buckets[1].max.value;
   
    console.log("minX = " + minX);
    console.log("maxX = " + maxX);
   
    console.log("minY = " + minY);
    console.log("maxY = " + maxY);  
   
   

    let lotno = 0;
    var traces = [];
    all_data.forEach(function(lot){
        var data = lot.UnitId.buckets.filter(function (d){
            return d.TestName.buckets.length === 2;
        });
        var lotNumber = lot.key;
        
        var x = [];
        var y =[];
        var unitid = [];
        
        let i = 0;
        data.forEach(function(unit){
            x[i] = unit.TestName.buckets[0].Avg.value;
            y[i] = unit.TestName.buckets[1].Avg.value;
            unitid[i] = unit.key;
            i++;
        });
        var trace = {
          x: x,
          y: y,
          mode: 'markers',
          type: 'scatter',
          name: lotNumber,
          text: unitid,
          marker: {size: 12, symbol: "diamond-open"}
        };
        traces[lotno] = trace;
        lotno ++;
        
    })
    
    var layout = { 
          /*
          xaxis: {
            range: [ 0.75, 5.25 ] 
          },
          yaxis: {
            range: [0, 8]
          },
          */
          title:'Data Labels Hover'
        };

    Plotly.newPlot('viz', traces, layout, {showSendToCloud: true});
  },
  
  count_hits: function() {
  return this.response.hits.hits.length;
 },
 count_aggs: function() {
     var a  = response.aggregations.UnitId.buckets;
     return a[0].TestName.buckets[0].Avg.value;
 },
  all_aggs: function() {
     var a = this.response.aggregations.UnitId.buckets;
     return a;
 },
 debug: function() {
  return JSON.stringify(this, null, ' ');
 } 
})





<div id="viz" style="color:blue; text-align:center; margin:0 auto;position: absolute;bottom: 0;top: 0; left:0; right: 0; font-size: 15px">
    
</div>


<!--This imports the library so that D3 can be used-->
{{meta.import_funnelLib}}




scatter_plotly

{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "Operation": {
              "value": "FT"
            }
          }
        },
        {
          "terms": {
            "LotNumber": [
              "HG50212",
              "HG50215"
            ]
          }
        },
        {
          "term": {
            "Type": {
              "value": "PinMeasure"
            }
          }
        },
        {
          "term": {
            "Pin": {
              "value": "S_VDDCR_SOC"
            }
          }
        }
      ],
      "filter": {
        "terms": {
          "context": [
            "Sidd_VddCrSoc_V1",
            "Sidd_VddCrSoc_V3"
          ]
        }
      }
    }
  },
  "size": 0,
  "aggs": {
    "LotNumber": {
      "terms": {
        "field": "LotNumber",
        "size": 2
      },
      "aggs": {
        "UnitId": {
          "terms": {
            "field": "UnitId",
            "size": 5000
          },
          "aggs": {
            "TestName": {
              "terms": {
                "field": "context"
              },
              "aggs": {
                "Avg": {
                  "avg": {
                    "field": "value"
                  }
                }
              }
            }
          }
        }
      }
    },
    "Helper":{
      "terms": {
        "field": "context",
        "size": 10
      },
      "aggs": {
        "max": {
          "max": {
            "field": "value"
          }
        },
        "min":{
          "min": {
            "field": "value"
          }
          
        }
      }
      
    }

    
  }
}

({
   after_render: function() {
       var innerContainer = document.getElementById('viz');
       var symbolSelector = innerContainer.querySelector('.symbolData');
       var colorSelector = innerContainer.querySelector('.colorsData');
       var sizeSelector = innerContainer.querySelector('.sizeData');
        
       function add_option (){
            var listofSymbos = ["diamond-open", "circle-open", "diamond", "circle-dot", "circle", "square-open", "square", "triangle-up-dot", "triangle-up-open-dot", "triangle-left-dot", "pentagon-dot", "hexagon-open",  "star-triangle-up-open-dot","hourglass-open","star-diamond-open-dot"];
            
            for (var i = 0; i < listofSymbos.length;  i++) {
                var currentOption = document.createElement('option');
                currentOption.text = listofSymbos[i];
               symbolSelector.appendChild(currentOption);
            }
            function updatesymbol(){
              console.log(symbolSelector.value);
            }
            symbolSelector.addEventListener('change', updatesymbol, false); 
       }
       
        add_option();
    
    
    // define the data
    var all_data = response.aggregations.LotNumber.buckets;
    var lot_data_0 = response.aggregations.LotNumber.buckets[0].UnitId.buckets;
    var lot_data_1 = response.aggregations.LotNumber.buckets[1].UnitId.buckets;
    
    var a = lot_data_0;
    var b = lot_data_1;
    
    var minX = 0;
    var minY = 0;
    var maxX = 0;
    var maxY = 0;
    
    
    minX = response.aggregations.Helper.buckets[0].min.value;
    maxX = response.aggregations.Helper.buckets[0].max.value;
    
    minY = response.aggregations.Helper.buckets[1].min.value;
    maxY = response.aggregations.Helper.buckets[1].max.value;
   /*
    console.log("minX = " + minX);
    console.log("maxX = " + maxX);
   
    console.log("minY = " + minY);
    console.log("maxY = " + maxY);  
    */
   

    let lotno = 0;
    var traces = [];
    
    all_data.forEach(function(lot){
        var data = lot.UnitId.buckets.filter(function (d){
            return d.TestName.buckets.length === 2;
        });
        var lotNumber = lot.key;
        
        var x = [];
        var y =[];
        var unitid = [];
        
        let i = 0;
        data.forEach(function(unit){
            x[i] = unit.TestName.buckets[0].Avg.value;
            y[i] = unit.TestName.buckets[1].Avg.value;
            unitid[i] = unit.key;
            i++;
        });
        var trace = {
          x: x,
          y: y,
          mode: 'markers',
          type: 'scatter',
          name: lotNumber,
          text: unitid,
          marker: {size: 12, symbol: symbolSelector[lotno].innerText}
        };
        traces[lotno] = trace;
        lotno ++;
        
    })
    
    var layout = { 
          hovermode:'closest',
          xaxis: {
            title: response.aggregations.Helper.buckets[0].key
          },
          yaxis: {
            title: response.aggregations.Helper.buckets[1].key
          },
          
          title: ''
        };

    Plotly.newPlot('viz', traces, layout, {showSendToCloud: true});
    
    innerContainer.on('plotly_click', function(data){
      //alert('You clicked this Plotly chart!');
      var pn='',
          tn='',
          colors=[];
      for(var i=0; i < data.points.length; i++){
        //pn = data.points[i].pointNumber;
        tn = data.points[i].curveNumber;
        //colors = data.points[i].data.marker.color;
        //console.log("i = " + i);
      }
      console.log(symbolSelector);
      
      //colors = '#C54C82';
        
      var update = {'marker':{color: colorSelector.value.split(":")[1], size:sizeSelector.value, symbol: symbolSelector.value}};
      Plotly.restyle('viz', update, [tn]);
    });
    innerContainer.on('plotly_restyle', function(data){
      //console.log(data);
    });
  },
  
 count_hits: function() {
  return this.response.hits.hits.length;
 },
 count_aggs: function() {
     var a  = response.aggregations.UnitId.buckets;
     return a[0].TestName.buckets[0].Avg.value;
 },
  all_aggs: function() {
     var a = this.response.aggregations.UnitId.buckets;
     return a;
 },
 debug: function() {
  return JSON.stringify(this, null, ' ');
 } 
})





<div id="viz" style="color:black; text-align:center; margin:0 auto;position: absolute;bottom: 0;top: 0; left:0; right: 0; font-size: 15px">
    <div class="control-row" style = "float: left">
        Country: <select class="symbolData">
        </select>
    </div>
    <div class="control-row" style = "float: right">
        Color: <select class="colorsData">
            <option>Red:#FF0000</option>
            <option>Green:#008000</option>
            <option>Yellow:#FFFF00</option>
            <option>Pink:#FFC0CB</option>
            <option>Brown:#A52A2A</option>
            <option>Blue:#0000FF</option>
            <option>Grey:#808080</option>
            <option>Orange:#FFA500</option>
            <option>SkyBlue:#87CEEB</option>
        </select>
    </div>
    <div class="control-row" style = "float: auto">
        Size: <select class="sizeData">
            <option>10</option>
            <option>12</option>
            <option>14</option>
            <option>16</option>
            <option>8</option>
             
        </select>
    </div>
</div>


<!--This imports the library so that D3 can be used-->
{{ meta.add_option }}
